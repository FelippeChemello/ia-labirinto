<!-- TODO: -->
<!-- Validar movC e movB quando estiver no limite do mapa -->
<!-- Só aumentar a numeração quando não for por hit em parede -->
<html>
  <head></head>
  <body>
    <div id="game"></div>
    <button onclick="window.algorithmType='blind'">Algoritmo Cego (Randomico)</button>
    <button onclick="window.algorithmType='heuristic'">Algoritmo Heuristico (Inteligente)</button>
    <button onclick="window.algorithmType=''">PARA</button>
    <div id="build">
        <h3 id='titulo'>Escolha a posição para Inicio do Labirinto</h3>
        <table> </table>
    </div>
    <script type="text/javascript" src="https://rawgithub.com/craftyjs/Crafty/release/dist/crafty-min.js"></script>
    <script>
    window.onload = () => {
        window.actions = {}
        window.dx = 0;
        window.dy = 0;
        window.count = 0;
        window.speed = 1;
        window.blockLength = 49;
        window.algorithmType;
        window.playerMap = [];
        window.oldValue = 0;
        window.passedPositions = [];

        loadTable()

        // window.actions.Inicio = "20";
        // window.actions.Final = "79";
        // window.actions.Paredes = ["10", "00", "01", "02", "12", "22", "32", "42", "41", "51", "61", "90", "80", "91", "92", "82", "73", "63", "43", "33", "23", "44", "45", "65", "75", "85", "83", "66", "67", "57", "47", "37", "27", "26", "25", "15", "07", "08", "09", "19", "29", "39", "49", "59", "69", "68", "86", "87", "76", "77", "99", "89"]

        // crafty()
    } 

    function crafty() {
        createPlayerMap();

        document.querySelector("#build").style.display = "none";

        Crafty.init(500, 500, document.querySelector('div#game'));
        Crafty.background('gray')

        criaElementosLinha();

        inicioX = retornaInicioX();
        inicioY = retornaInicioY();
        
        window.cubo = Crafty.e('Cubo, Canvas, Color, Fourway, Collision')
            .attr({x: inicioX, y: inicioY+5, w: 25, h: 25})
            .color('#F00')
            .fourway(200)
            .bind('UpdateFrame', () => {
                window.cubo.x += window.dx;
                window.cubo.y += window.dy;
                window.count++;
                if (window.algorithmType == 'blind') {
                    blindAlgorithm()
                } else if (window.algorithmType == 'heuristic') {
                    heuristicAlgorithm()
                }
            })
            .bind('Move', function() {
                if (this.hit('Finish')) {
                    desenhaCaminhoTrilhado();
                    alert("Parabens\nVocê ganhou");
                    window.algorithmType = '';
                    stopMov();
                }
                if (this.hit('Obstaculo')) {
                    if (window.algorithmType == 'blind') {
                        blindAlgorithmHit()
                    } else {
                        heuristicAlgorithmHit()
                    }
                }
            })

        craftyMontaBordas();
        craftyMontaObstaculos();       
    };

    function heuristicAlgorithmHit() {
        window.cubeState = 'wait';
        window.count = 0;

        const direction = getMovementDirection();
        const pos = getCurrentPlayerLocation();

        try {
            switch (direction) {
                case 'd': window.playerMap[pos.y][pos.x+1] += 99; break;
                case 'e': window.playerMap[pos.y][pos.x-1] += 99; break;
                case 'c': window.playerMap[pos.y-1][pos.x] += 99; break;
                case 'b': window.playerMap[pos.y+1][pos.x] += 99; break;
            }
        } catch (e) {
            console.error("ERRO")
            console.log(window.playerMap);
        }

        window.dx = -1*window.dx;
        window.dy = -1*window.dy;
    }

    function getMovementDirection() {
        if (window.dx > 0) return 'd';
        if (window.dx < 0) return 'e';
        if (window.dy < 0) return 'c';
        if (window.dy > 0) return 'b';
    }

    function getCurrentPlayerLocation() {
        const obj = {};
        obj.x = Math.floor((window.cubo.x + 10)/window.blockLength); //Soma-se 10 devido a parede
        obj.y = Math.floor((window.cubo.y + 10 )/window.blockLength); //Soma-se 10 devido a parede

        return obj;
    }

    function heuristicAlgorithm() {
        if (window.cubeState == 'wait' && window.count > 3) {
            stopMov();
            window.cubeState = '';
        } else if (window.count > window.blockLength) {
            stopMov()
            saveLocation()
            const paths = getPathsAvailable()
            const bestPath = getBestPath(paths)
            heuristicMove(bestPath);
        }
    }

    function heuristicMove(mov) {
        updatePlayerMapPosition(1)
        saveLocation()
        
        switch (mov) {
            case 'movD': window.dx = window.speed; break;
            case 'movE': window.dx = -window.speed; break;
            case 'movC': window.dy = -window.speed; break;
            case 'movB': window.dy = window.speed; break
        }
        console.log(mov)
        window.count = 0;
    }
    
    function updatePlayerMapPosition(set) {
        const pos = getCurrentPlayerLocation();
        backupPlayerMap()
        if (isNaN(set)) {
            window.oldValue = window.playerMap[pos.y][pos.x]
            window.playerMap[pos.y][pos.x] = set;
        } else {
            if (isNaN(window.playerMapBkp[pos.y][pos.x])) {
                window.playerMap[pos.y][pos.x] = set + window.playerMapBkp[pos.y][pos.x];  
            }else{
                window.playerMap[pos.y][pos.x] = (window.playerMapBkp[pos.y][pos.x] + set);
            }
        }
    }

    function backupPlayerMap() {
        window.playerMapBkp = window.playerMap;
        
        for (linha in playerMapBkp) {
            for (coluna in playerMapBkp[linha]) {
                if (playerMapBkp[linha][coluna] == 'x') {
                    playerMapBkp[linha][coluna] = window.oldValue;
                }
            }
        }
    }

    function getBestPath(paths) {
        delete paths.posLinha;
        delete paths.posColuna;
        
        let lowerValue = Math.min(...Object.values(paths))
        
        for (const mov in paths) {
            if (paths[mov] > lowerValue) {
                delete paths[mov];
            }
        }
        
        //Se mais de um caminho for disponivel, pega um aleatorio, se nao, envia aquele mesmo
        return randomProperty(paths);
    }

    function getPathsAvailable() {
        const obj = {};

        // window.playerMap.forEach((elementoLinha, indexLinha, array) => {
        //     elementoLinha.forEach((elementoColuna, indexColuna, arrayLinha) => {
        //         if (elementoColuna == 'x') {
        //             obj.posLinha = indexLinha;
        //             obj.posColuna = indexColuna;
        //         }
        //     })
        // })

        const position = getCurrentPlayerLocation()

        obj.posLinha = position.y;
        obj.posColuna = position.x;

        const tempMovD = window.playerMap[obj.posLinha]?.[obj.posColuna+1];
        const tempMovE = window.playerMap[obj.posLinha]?.[obj.posColuna-1];
        const tempMovC = window.playerMap[obj.posLinha-1]?.[obj.posColuna];
        const tempMovB = window.playerMap[obj.posLinha+1]?.[obj.posColuna];

        obj.movD = (tempMovD !== undefined && tempMovD !== NaN) ? tempMovD : 999;
        obj.movE = (tempMovE !== undefined && tempMovE !== NaN) ? tempMovE : 999;
        obj.movC = (tempMovC !== undefined && tempMovC !== NaN) ? tempMovC : 999;
        obj.movB = (tempMovB !== undefined && tempMovB !== NaN) ? tempMovB : 999;
        
        return obj;
    }

    function createPlayerMap() {
        for (let i = 0; i < 10; i++) {
            window.playerMap.push(new Array(10).fill(null))
        }

        // let linhaJogador = window.actions.Inicio[0];
        // let colunaJogador = window.actions.Inicio[1];
        // window.playerMap[linhaJogador][colunaJogador] = 'x';

        let linhaFinal = window.actions.Final[0]
        let colunaFinal = window.actions.Final[1];
        window.playerMap[linhaFinal][colunaFinal] = -1;

        window.actions.Paredes.forEach((elemento, index, arr) => {
            let linha = elemento[0];
            let coluna = elemento[1];
            
            window.playerMap[linha][coluna] = 999;
        });   

        obtemMelhorCaminhoPartindoDoDestino()

        console.log(window.playerMap)
    }

    function obtemMelhorCaminhoPartindoDoDestino() {
        o = 0;
        first = true;
        do{
            for (let k = 0; k <= countElementInMatrix(o) || first; k++){
                first = false;
                window.playerMap.forEach((linha, indexLinha, array) => {
                    linha.forEach((element, indexColuna, arr) => {
                        if (element == o-1){
                            try {
                                const posD = window.playerMap[indexLinha]?.[indexColuna+1];
                                const posE = window.playerMap[indexLinha]?.[indexColuna-1];
                                const posC = window.playerMap[indexLinha-1]?.[indexColuna];
                                const posB = window.playerMap[indexLinha+1]?.[indexColuna];

                                if (posD !== undefined && posD !== NaN && posD !== 999 && posD == null) {
                                    window.playerMap[indexLinha][indexColuna+1] = o;
                                }
                                if (posE !== undefined && posE !== NaN && posE !== 999 && posE == null) {
                                    window.playerMap[indexLinha][indexColuna-1] = o;
                                }
                                if (posC !== undefined && posC !== NaN && posC !== 999 && posC == null) {
                                    window.playerMap[indexLinha-1][indexColuna] = o;
                                }
                                if (posB !== undefined && posB !== NaN && posB !== 999 && posB == null) {
                                    window.playerMap[indexLinha+1][indexColuna] = o;
                                }                                
                            }catch (e) {
                                console.log("Posicao inválida\n Linha: " + indexLinha + " Coluna: " + indexColuna)
                            }
                        }
                    })
                })       
            }
            o++;
        }while (countElementInMatrix(null) > 0)
    }

    function countElementInMatrix(number) {
        let count = 0;
        window.playerMap.forEach((linha, index, array) => {
            linha.forEach((element, i, arr) => {
                if (element == number) {
                    count++;
                }
            })
        })

        return count;
    }

    function randomProperty (obj) {
        var keys = Object.keys(obj);
        return keys[ keys.length * Math.random() << 0];
    };

    function blindAlgorithm() {
        if (window.count > window.stopped+1) {
            stopMov()
            getNewRandomMove()
            window.state = '';
        }
        if (window.count > window.blockLength/window.speed) {
            stopMov()
            saveLocation()
            getNewRandomMove()
        }
    }

    function blindAlgorithmHit() {
        invertMov()
    }

    function invertMov() {
        window.stopped = window.count;
        window.cubeState = 'wait';
        window.dx = -1*window.dx;
        window.dy = -1*window.dy;
    }

    function stopMov() {
        window.stopped = 99999999999;
        window.count = 0;
        window.dx = 0;
        window.dy = 0;
    }

    function getNewRandomMove() {
        switch (getRandomInt(1, 5)) {
            case 1: window.dx = window.speed; break;
            case 2: window.dx = -window.speed; break;
            case 3: window.dy = window.speed; break;
            case 4: window.dy = -window.speed; break;
            default: console.error("ERRO")
        }
    }

    function getRandomInt(min, max) {
        min = Math.ceil(min);
        max = Math.floor(max);
        return Math.floor(Math.random() * (max - min)) + min;
    }

    function craftyMontaObstaculos() {
        window.actions.Paredes.forEach((elemento, index, arr) => {
            let linha = elemento[0];
            let coluna = elemento[1];
            
            Crafty.e('Obstaculo, 2D, Canvas, Color')
                .attr({ x: window.blockLength*coluna, 
                        y: window.blockLength*linha, 
                        w: window.blockLength, 
                        h: window.blockLength})
                .color('black');   
        });   

        let linha = window.actions.Final[0];
        let coluna = window.actions.Final[1];
        Crafty.e('Finish, 2D, Canvas, Color')
            .attr({ x: window.blockLength*coluna, 
                    y: window.blockLength*linha, 
                    w: window.blockLength, 
                    h: window.blockLength})
            .color('yellow');   

    }

    function retornaInicioX() {
        let linha = window.actions.Inicio[1];
        return linha*window.blockLength+10
    }

    function retornaInicioY() {
        let coluna = window.actions.Inicio[0];
        return coluna*window.blockLength+10
    }

    function craftyMontaBordas() {
        Crafty.e('Obstaculo, 2D, Canvas, Color')
            .attr({x: 0, y: 0, w: 500, h: 10})
            .color('black');
        
        Crafty.e('Obstaculo, 2D, Canvas, Color')
            .attr({x: 0, y: 0, w: 10, h: 500})
            .color('black');

        Crafty.e('Obstaculo, 2D, Canvas, Color')
            .attr({x: 490, y: 0, w: 10, h: 500})
            .color('black');

        Crafty.e('Obstaculo, 2D, Canvas, Color')
            .attr({x: 0, y: 490, w: 500, h: 10})
            .color('black');
    }

    function loadTable() {
        window.actions = {
            'Inicio': null,
            'Final': null,
            'Paredes': []
        }
        var tbdy = document.createElement('tbody');
        for (var i = 0; i < 10; i++) {
            var tr = document.createElement('tr');
            for (var j = 0; j < 10; j++) {
                const id = `${i}${j}`;
                var button = document.createElement('button');
                button.style.height = "25px";
                button.style.width = "25px";
                button.setAttribute('id', id)
                button.onclick = function(el) {
                    if (!window.actions.Inicio) {
                        el.target.innerText = "I"
                        window.actions.Inicio = el.target.id;
                        trocaFraseDeSolicitacao()
                    } else if (!window.actions.Final) {
                        el.target.innerText = "F"
                        window.actions.Final = el.target.id;
                        trocaFraseDeSolicitacao()
                    } else {
                        el.target.innerText = "X"
                        window.actions.Paredes.push(el.target.id);
                    }
                }
                var td = document.createElement('td');
                td.appendChild(button)
                tr.appendChild(td)
            }
            tbdy.appendChild(tr);
        }
        document.querySelector('table').appendChild(tbdy);
    }

    function trocaFraseDeSolicitacao() {
        const h3 = document.querySelector('h3#titulo');
        if (!window.actions.Final) {
            h3.innerText = "Selecione a posição para Destino do Labirinto"
        } else {
            h3.innerHTML = "Clique para adicionar paredes ao Labirinto. <br> <button onclick='crafty()'> Quando estiver finalizado clique aqui</button>";       }
    }

    function saveLocation() {
        const pos = getCurrentPlayerLocation();

        const posFromMatrix = parseInt(`${pos.y}${pos.x}`);

        window.passedPositions.push(posFromMatrix);
    }

    function desenhaCaminhoTrilhado() {
        // window.passedPositions = [20, 30, 40, 50, 60, 70, 71, 72, 62, 52, 53, 54, 64, 74, 84, 94, 95, 96, 97, 98, 88, 78];
        window.passedPositions.forEach((element, index, array) => {
            const linha = parseInt(element.toString()[0])*49;
            const coluna = parseInt(element.toString()[1])*49;

            let mov;
            if (array[index+1]){
                const proxLinha = parseInt(array[index+1].toString()[0])*49;
                const proxColuna = parseInt(array[index+1].toString()[1])*49;
                
                if (parseInt(proxLinha) != NaN && proxLinha > linha) {
                    Crafty.e("LineBaixo").attr({x: coluna + 25, y: linha + 25})
                    mov = 'B'
                } else if (parseInt(proxLinha) != NaN && proxLinha < linha) {
                    Crafty.e("LineCima").attr({x: coluna + 25, y: linha + 25})
                    mov = 'C'
                } else if (parseInt(proxColuna) != NaN && proxColuna > coluna) {
                    Crafty.e("LineDireita").attr({x: coluna + 25, y: linha + 25})
                    mov = 'D'
                } else if (parseInt(proxColuna) != NaN && proxColuna < coluna) {
                    Crafty.e("LineEsquerda").attr({x: coluna + 25, y: linha + 25})
                    mov = 'E'
                } else {
                    console.error(element, array[index+1]);
                }

                console.log(linha, coluna, mov)
            }
        })
    }

    function criaElementosLinha() {
        Crafty.c("LineBaixo", {
            init: function () {
                this.requires("2D, Canvas, Color");
                this.bind("Draw", this._draw_me);
                this.ready = true;
            },
            _draw_me: function (e) {
                var ctx = e.ctx;
                ctx.lineWidth = 2;
                ctx.strokeStyle = "#39FF14";
                ctx.beginPath();
                ctx.moveTo(e.pos._x, e.pos._y);
                ctx.lineTo(e.pos._x, e.pos._y + 49);
                ctx.stroke();
            }
        });

        Crafty.c("LineCima", {
            init: function () {
                this.requires("2D, Canvas, Color");
                this.bind("Draw", this._draw_me);
                this.ready = true;
            },
            _draw_me: function (e) {
                var ctx = e.ctx;
                ctx.lineWidth = 2;
                ctx.strokeStyle = "#39FF14";
                ctx.beginPath();
                ctx.moveTo(e.pos._x, e.pos._y);
                ctx.lineTo(e.pos._x, e.pos._y - 49);
                ctx.stroke();
            }
        });

        Crafty.c("LineDireita", {
            init: function () {
                this.requires("2D, Canvas, Color");
                this.bind("Draw", this._draw_me);
                this.ready = true;
            },
            _draw_me: function (e) {
                var ctx = e.ctx;
                ctx.lineWidth = 2;
                ctx.strokeStyle = "#39FF14";
                ctx.beginPath();
                ctx.moveTo(e.pos._x, e.pos._y);
                ctx.lineTo(e.pos._x + 49, e.pos._y);
                ctx.stroke();
            }
        });

        Crafty.c("LineEsquerda", {
            init: function () {
                this.requires("2D, Canvas, Color");
                this.bind("Draw", this._draw_me);
                this.ready = true;
            },
            _draw_me: function (e) {
                var ctx = e.ctx;
                ctx.lineWidth = 2;
                ctx.strokeStyle = "#39FF14";
                ctx.beginPath();
                ctx.moveTo(e.pos._x, e.pos._y);
                ctx.lineTo(e.pos._x - 49, e.pos._y);
                ctx.stroke();
            }
        });
    }
    </script>
  </body>
</html>